CCS PCM C Compiler, Version 5.074, 32906               03-เม.ย.-20 10:52

               Filename:   D:\Ronnachai\CPE Couse\261214 Microprocessor and Interfacing\game\2048\main.lst

               ROM used:   2044 words (25%)
                           Largest free fragment is 2048
               RAM used:   69 (19%) at main() level
                           81 (22%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   40B
0003:  NOP
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
0004:  DATA 89,04
0005:  DATA 3C,10
0006:  DATA D7,32
0007:  DATA EC,31
0008:  DATA EF,36
0009:  DATA 65,10
000A:  DATA F4,37
000B:  DATA 20,19
000C:  DATA 30,1A
000D:  DATA 38,10
000E:  DATA E7,30
000F:  DATA ED,32
0010:  DATA 20,1F
0011:  DATA 0D,05
0012:  DATA 00,00
0013:  DATA A7,30
0014:  DATA 27,10
0015:  DATA 3D,10
0016:  DATA CC,32
0017:  DATA 66,3A
0018:  DATA 20,10
0019:  DATA 27,32
001A:  DATA 27,10
001B:  DATA 3D,10
001C:  DATA D2,34
001D:  DATA 67,34
001E:  DATA 74,10
001F:  DATA A0,13
0020:  DATA F7,13
0021:  DATA A0,1E
0022:  DATA A0,2A
0023:  DATA 70,10
0024:  DATA A0,13
0025:  DATA F3,13
0026:  DATA A0,1E
0027:  DATA 20,22
0028:  DATA EF,3B
0029:  DATA EE,06
002A:  DATA 0A,05
002B:  DATA 00,01
002C:  DATA 8C,2C
002D:  DATA EF,3A
002E:  DATA 72,10
002F:  DATA F3,31
0030:  DATA 6F,39
0031:  DATA 65,05
0032:  DATA A5,3A
0033:  DATA 00,00
0034:  DATA 89,04
0035:  DATA 89,10
0036:  DATA C7,30
0037:  DATA ED,32
0038:  DATA A0,27
0039:  DATA F6,32
003A:  DATA F2,10
003B:  DATA 0D,05
003C:  DATA 00,01
003D:  DATA 89,04
003E:  DATA 61,32
003F:  DATA 64,10
0040:  DATA EE,32
0041:  DATA 77,10
0042:  DATA 5B,19
0043:  DATA 5D,10
0044:  DATA 69,37
0045:  DATA 20,14
0046:  DATA 25,32
0047:  DATA AC,12
0048:  DATA E4,14
0049:  DATA 0D,05
004A:  DATA 00,00
004B:  DATA 89,04
004C:  DATA 89,16
004D:  DATA AD,16
004E:  DATA 2D,26
004F:  DATA 65,33
0050:  DATA F4,16
0051:  DATA AD,16
0052:  DATA AD,06
0053:  DATA 0A,00
0054:  DATA 89,04
0055:  DATA 89,16
0056:  DATA AD,16
0057:  DATA D2,34
0058:  DATA 67,34
0059:  DATA F4,16
005A:  DATA AD,16
005B:  DATA 0D,05
005C:  DATA 00,01
005D:  DATA 89,04
005E:  DATA 89,16
005F:  DATA AD,16
0060:  DATA 2D,2A
0061:  DATA 6F,38
0062:  DATA AD,16
0063:  DATA AD,16
0064:  DATA 0D,05
0065:  DATA 00,01
0066:  DATA 89,04
0067:  DATA 89,16
0068:  DATA AD,16
0069:  DATA C2,37
006A:  DATA 74,3A
006B:  DATA EF,36
006C:  DATA AD,16
006D:  DATA AD,06
006E:  DATA 0A,00
*
0182:  MOVF   0B,W
0183:  MOVWF  5D
0184:  BCF    0B.7
0185:  BSF    03.5
0186:  BSF    03.6
0187:  BSF    0C.7
0188:  BSF    0C.0
0189:  NOP
018A:  NOP
018B:  BCF    03.5
018C:  BCF    03.6
018D:  BTFSC  5D.7
018E:  BSF    0B.7
018F:  BSF    03.6
0190:  MOVF   0C,W
0191:  ANDLW  7F
0192:  BTFSC  03.2
0193:  GOTO   1D8
0194:  BCF    03.6
0195:  MOVWF  5D
0196:  BSF    03.6
0197:  MOVF   0D,W
0198:  BCF    03.6
0199:  MOVWF  5E
019A:  BSF    03.6
019B:  MOVF   0F,W
019C:  BCF    03.6
019D:  MOVWF  5F
019E:  MOVF   5D,W
019F:  BTFSS  0C.4
01A0:  GOTO   19F
01A1:  MOVWF  19
01A2:  MOVF   5E,W
01A3:  BSF    03.6
01A4:  MOVWF  0D
01A5:  BCF    03.6
01A6:  MOVF   5F,W
01A7:  BSF    03.6
01A8:  MOVWF  0F
01A9:  BCF    03.6
01AA:  MOVF   0B,W
01AB:  MOVWF  60
01AC:  BCF    0B.7
01AD:  BSF    03.5
01AE:  BSF    03.6
01AF:  BSF    0C.7
01B0:  BSF    0C.0
01B1:  NOP
01B2:  NOP
01B3:  BCF    03.5
01B4:  BCF    03.6
01B5:  BTFSC  60.7
01B6:  BSF    0B.7
01B7:  BSF    03.6
01B8:  RLF    0C,W
01B9:  RLF    0E,W
01BA:  ANDLW  7F
01BB:  BTFSC  03.2
01BC:  GOTO   1D8
01BD:  BCF    03.6
01BE:  MOVWF  5D
01BF:  BSF    03.6
01C0:  MOVF   0D,W
01C1:  BCF    03.6
01C2:  MOVWF  5E
01C3:  BSF    03.6
01C4:  MOVF   0F,W
01C5:  BCF    03.6
01C6:  MOVWF  5F
01C7:  MOVF   5D,W
01C8:  BTFSS  0C.4
01C9:  GOTO   1C8
01CA:  MOVWF  19
01CB:  MOVF   5E,W
01CC:  BSF    03.6
01CD:  MOVWF  0D
01CE:  BCF    03.6
01CF:  MOVF   5F,W
01D0:  BSF    03.6
01D1:  MOVWF  0F
01D2:  INCF   0D,F
01D3:  BTFSC  03.2
01D4:  INCF   0F,F
01D5:  BCF    03.6
01D6:  GOTO   182
01D7:  BSF    03.6
01D8:  BCF    03.6
01D9:  RETURN
*
0223:  MOVF   0B,W
0224:  MOVWF  5E
0225:  BCF    0B.7
0226:  BSF    03.5
0227:  BSF    03.6
0228:  BSF    0C.7
0229:  BSF    0C.0
022A:  NOP
022B:  NOP
022C:  BCF    03.5
022D:  BCF    03.6
022E:  BTFSC  5E.7
022F:  BSF    0B.7
0230:  BTFSC  03.0
0231:  GOTO   25A
0232:  BSF    03.6
0233:  MOVF   0C,W
0234:  ANDLW  7F
0235:  BCF    03.6
0236:  MOVWF  5E
0237:  BSF    03.6
0238:  MOVF   0D,W
0239:  BCF    03.6
023A:  MOVWF  5F
023B:  BSF    03.6
023C:  MOVF   0F,W
023D:  BCF    03.6
023E:  MOVWF  60
023F:  MOVF   5E,W
0240:  MOVWF  61
0241:  CALL   1F7
0242:  MOVF   5F,W
0243:  BSF    03.6
0244:  MOVWF  0D
0245:  BCF    03.6
0246:  MOVF   60,W
0247:  BSF    03.6
0248:  MOVWF  0F
0249:  BCF    03.6
024A:  MOVF   0B,W
024B:  MOVWF  61
024C:  BCF    0B.7
024D:  BSF    03.5
024E:  BSF    03.6
024F:  BSF    0C.7
0250:  BSF    0C.0
0251:  NOP
0252:  NOP
0253:  BCF    03.5
0254:  BCF    03.6
0255:  BTFSC  61.7
0256:  BSF    0B.7
0257:  DECFSZ 5D,F
0258:  GOTO   25A
0259:  GOTO   279
025A:  BSF    03.6
025B:  RLF    0C,W
025C:  RLF    0E,W
025D:  ANDLW  7F
025E:  BCF    03.6
025F:  MOVWF  5E
0260:  BSF    03.6
0261:  MOVF   0D,W
0262:  BCF    03.6
0263:  MOVWF  5F
0264:  BSF    03.6
0265:  MOVF   0F,W
0266:  BCF    03.6
0267:  MOVWF  60
0268:  MOVF   5E,W
0269:  MOVWF  61
026A:  CALL   1F7
026B:  MOVF   5F,W
026C:  BSF    03.6
026D:  MOVWF  0D
026E:  BCF    03.6
026F:  MOVF   60,W
0270:  BSF    03.6
0271:  MOVWF  0F
0272:  INCF   0D,F
0273:  BTFSC  03.2
0274:  INCF   0F,F
0275:  BCF    03.0
0276:  BCF    03.6
0277:  DECFSZ 5D,F
0278:  GOTO   223
0279:  BCF    0A.3
027A:  BCF    0A.4
027B:  GOTO   495 (RETURN)
027C:  MOVF   66,W
027D:  CLRF   78
027E:  SUBWF  65,W
027F:  BTFSC  03.0
0280:  GOTO   284
0281:  MOVF   65,W
0282:  MOVWF  77
0283:  GOTO   290
0284:  CLRF   77
0285:  MOVLW  08
0286:  MOVWF  67
0287:  RLF    65,F
0288:  RLF    77,F
0289:  MOVF   66,W
028A:  SUBWF  77,W
028B:  BTFSC  03.0
028C:  MOVWF  77
028D:  RLF    78,F
028E:  DECFSZ 67,F
028F:  GOTO   287
0290:  RETURN
0291:  MOVF   78,W
0292:  MOVF   5D,W
0293:  MOVWF  65
0294:  MOVLW  64
0295:  MOVWF  66
0296:  CALL   27C
0297:  MOVF   77,W
0298:  MOVWF  5D
0299:  MOVF   78,W
029A:  MOVLW  30
029B:  BTFSS  03.2
029C:  GOTO   2A4
029D:  BTFSS  5E.1
029E:  GOTO   2AB
029F:  BTFSC  5E.3
02A0:  GOTO   2AB
02A1:  BTFSC  5E.4
02A2:  MOVLW  20
02A3:  GOTO   2A7
02A4:  BCF    5E.3
02A5:  BCF    5E.4
02A6:  BSF    5E.0
02A7:  ADDWF  78,F
02A8:  MOVF   78,W
02A9:  MOVWF  61
02AA:  CALL   1F7
02AB:  MOVF   5D,W
02AC:  MOVWF  65
02AD:  MOVLW  0A
02AE:  MOVWF  66
02AF:  CALL   27C
02B0:  MOVF   77,W
02B1:  MOVWF  5D
02B2:  MOVF   78,W
02B3:  MOVLW  30
02B4:  BTFSS  03.2
02B5:  GOTO   2BC
02B6:  BTFSC  5E.3
02B7:  GOTO   2C0
02B8:  BTFSS  5E.0
02B9:  GOTO   2C0
02BA:  BTFSC  5E.4
02BB:  MOVLW  20
02BC:  ADDWF  78,F
02BD:  MOVF   78,W
02BE:  MOVWF  61
02BF:  CALL   1F7
02C0:  MOVLW  30
02C1:  ADDWF  5D,F
02C2:  MOVF   5D,W
02C3:  MOVWF  61
02C4:  CALL   1F7
02C5:  BCF    0A.3
02C6:  BCF    0A.4
02C7:  GOTO   49A (RETURN)
02C8:  CLRF   78
02C9:  CLRF   79
02CA:  CLRF   77
02CB:  CLRF   7A
02CC:  MOVF   63,W
02CD:  BTFSS  03.2
02CE:  GOTO   2D2
02CF:  MOVF   62,W
02D0:  BTFSC  03.2
02D1:  GOTO   2EC
02D2:  MOVLW  10
02D3:  MOVWF  64
02D4:  BCF    03.0
02D5:  RLF    60,F
02D6:  RLF    61,F
02D7:  RLF    77,F
02D8:  RLF    7A,F
02D9:  MOVF   63,W
02DA:  SUBWF  7A,W
02DB:  BTFSS  03.2
02DC:  GOTO   2DF
02DD:  MOVF   62,W
02DE:  SUBWF  77,W
02DF:  BTFSS  03.0
02E0:  GOTO   2E8
02E1:  MOVF   62,W
02E2:  SUBWF  77,F
02E3:  BTFSS  03.0
02E4:  DECF   7A,F
02E5:  MOVF   63,W
02E6:  SUBWF  7A,F
02E7:  BSF    03.0
02E8:  RLF    78,F
02E9:  RLF    79,F
02EA:  DECFSZ 64,F
02EB:  GOTO   2D4
02EC:  RETURN
*
02FD:  MOVLW  20
02FE:  MOVWF  69
02FF:  CLRF   65
0300:  CLRF   66
0301:  CLRF   67
0302:  CLRF   68
0303:  MOVF   60,W
0304:  MOVWF  7A
0305:  MOVF   5F,W
0306:  MOVWF  79
0307:  MOVF   5E,W
0308:  MOVWF  78
0309:  MOVF   5D,W
030A:  MOVWF  77
030B:  BCF    03.0
030C:  BTFSS  77.0
030D:  GOTO   31C
030E:  MOVF   61,W
030F:  ADDWF  65,F
0310:  MOVF   62,W
0311:  BTFSC  03.0
0312:  INCFSZ 62,W
0313:  ADDWF  66,F
0314:  MOVF   63,W
0315:  BTFSC  03.0
0316:  INCFSZ 63,W
0317:  ADDWF  67,F
0318:  MOVF   64,W
0319:  BTFSC  03.0
031A:  INCFSZ 64,W
031B:  ADDWF  68,F
031C:  RRF    68,F
031D:  RRF    67,F
031E:  RRF    66,F
031F:  RRF    65,F
0320:  RRF    7A,F
0321:  RRF    79,F
0322:  RRF    78,F
0323:  RRF    77,F
0324:  DECFSZ 69,F
0325:  GOTO   30B
*
0355:  MOVLW  20
0356:  BTFSS  60.4
0357:  MOVLW  30
0358:  MOVWF  61
0359:  MOVF   5F,W
035A:  MOVWF  77
035B:  BTFSS  5F.7
035C:  GOTO   365
035D:  COMF   77,F
035E:  INCF   77,F
035F:  MOVF   77,W
0360:  MOVWF  5F
0361:  MOVLW  2D
0362:  MOVWF  61
0363:  BSF    60.7
0364:  BSF    60.0
0365:  MOVF   5F,W
0366:  MOVWF  65
0367:  MOVLW  64
0368:  MOVWF  66
0369:  CALL   27C
036A:  MOVF   77,W
036B:  MOVWF  5F
036C:  MOVLW  30
036D:  ADDWF  78,W
036E:  MOVWF  62
036F:  MOVF   5F,W
0370:  MOVWF  65
0371:  MOVLW  0A
0372:  MOVWF  66
0373:  CALL   27C
0374:  MOVLW  30
0375:  ADDWF  77,W
0376:  MOVWF  64
0377:  MOVLW  30
0378:  ADDWF  78,W
0379:  MOVWF  63
037A:  MOVF   61,W
037B:  MOVWF  77
037C:  MOVLW  30
037D:  SUBWF  62,W
037E:  BTFSC  03.2
037F:  GOTO   384
0380:  BSF    60.1
0381:  BTFSC  60.7
0382:  BSF    60.2
0383:  GOTO   398
0384:  MOVF   61,W
0385:  MOVWF  62
0386:  MOVLW  20
0387:  MOVWF  61
0388:  MOVLW  30
0389:  SUBWF  63,W
038A:  BTFSC  03.2
038B:  GOTO   390
038C:  BSF    60.0
038D:  BTFSC  60.7
038E:  BSF    60.1
038F:  GOTO   398
0390:  BTFSS  03.2
0391:  BSF    60.0
0392:  BTFSS  03.2
0393:  GOTO   398
0394:  MOVF   62,W
0395:  MOVWF  63
0396:  MOVLW  20
0397:  MOVWF  62
0398:  BTFSC  60.2
0399:  GOTO   39F
039A:  BTFSC  60.1
039B:  GOTO   3A3
039C:  BTFSC  60.0
039D:  GOTO   3A7
039E:  GOTO   3AB
039F:  MOVF   61,W
03A0:  BTFSS  0C.4
03A1:  GOTO   3A0
03A2:  MOVWF  19
03A3:  MOVF   62,W
03A4:  BTFSS  0C.4
03A5:  GOTO   3A4
03A6:  MOVWF  19
03A7:  MOVF   63,W
03A8:  BTFSS  0C.4
03A9:  GOTO   3A8
03AA:  MOVWF  19
03AB:  MOVF   64,W
03AC:  BTFSS  0C.4
03AD:  GOTO   3AC
03AE:  MOVWF  19
03AF:  RETURN
03B0:  MOVF   0B,W
03B1:  MOVWF  60
03B2:  BCF    0B.7
03B3:  BSF    03.5
03B4:  BSF    03.6
03B5:  BSF    0C.7
03B6:  BSF    0C.0
03B7:  NOP
03B8:  NOP
03B9:  BCF    03.5
03BA:  BCF    03.6
03BB:  BTFSC  60.7
03BC:  BSF    0B.7
03BD:  BTFSC  03.0
03BE:  GOTO   3E8
03BF:  BSF    03.6
03C0:  MOVF   0C,W
03C1:  ANDLW  7F
03C2:  BCF    03.6
03C3:  MOVWF  60
03C4:  BSF    03.6
03C5:  MOVF   0D,W
03C6:  BCF    03.6
03C7:  MOVWF  61
03C8:  BSF    03.6
03C9:  MOVF   0F,W
03CA:  BCF    03.6
03CB:  MOVWF  62
03CC:  MOVF   60,W
03CD:  BTFSS  0C.4
03CE:  GOTO   3CD
03CF:  MOVWF  19
03D0:  MOVF   61,W
03D1:  BSF    03.6
03D2:  MOVWF  0D
03D3:  BCF    03.6
03D4:  MOVF   62,W
03D5:  BSF    03.6
03D6:  MOVWF  0F
03D7:  BCF    03.6
03D8:  MOVF   0B,W
03D9:  MOVWF  63
03DA:  BCF    0B.7
03DB:  BSF    03.5
03DC:  BSF    03.6
03DD:  BSF    0C.7
03DE:  BSF    0C.0
03DF:  NOP
03E0:  NOP
03E1:  BCF    03.5
03E2:  BCF    03.6
03E3:  BTFSC  63.7
03E4:  BSF    0B.7
03E5:  DECFSZ 5F,F
03E6:  GOTO   3E8
03E7:  GOTO   408
03E8:  BSF    03.6
03E9:  RLF    0C,W
03EA:  RLF    0E,W
03EB:  ANDLW  7F
03EC:  BCF    03.6
03ED:  MOVWF  60
03EE:  BSF    03.6
03EF:  MOVF   0D,W
03F0:  BCF    03.6
03F1:  MOVWF  61
03F2:  BSF    03.6
03F3:  MOVF   0F,W
03F4:  BCF    03.6
03F5:  MOVWF  62
03F6:  MOVF   60,W
03F7:  BTFSS  0C.4
03F8:  GOTO   3F7
03F9:  MOVWF  19
03FA:  MOVF   61,W
03FB:  BSF    03.6
03FC:  MOVWF  0D
03FD:  BCF    03.6
03FE:  MOVF   62,W
03FF:  BSF    03.6
0400:  MOVWF  0F
0401:  INCF   0D,F
0402:  BTFSC  03.2
0403:  INCF   0F,F
0404:  BCF    03.0
0405:  BCF    03.6
0406:  DECFSZ 5F,F
0407:  GOTO   3B0
0408:  BCF    0A.3
0409:  BCF    0A.4
040A:  GOTO   5FB (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 *=16   
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin not enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES BROWNOUT                 //Brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES INTRC_IO  
....................  
.................... #use delay(clock=8M) 
*
006F:  MOVLW  62
0070:  MOVWF  04
0071:  BCF    03.7
0072:  MOVF   00,W
0073:  BTFSC  03.2
0074:  GOTO   082
0075:  MOVLW  02
0076:  MOVWF  78
0077:  CLRF   77
0078:  DECFSZ 77,F
0079:  GOTO   078
007A:  DECFSZ 78,F
007B:  GOTO   077
007C:  MOVLW  97
007D:  MOVWF  77
007E:  DECFSZ 77,F
007F:  GOTO   07E
0080:  DECFSZ 00,F
0081:  GOTO   075
0082:  RETURN
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() and asctime() have another optional input parameter which /// 
.................... ///     is the pointer to where to save the result string.                /// 
.................... ///     Normally ctime() and asctime() write the output to a globally     /// 
.................... ///     allocated string and return a pointer to this string.  By using   /// 
.................... ///     this optional extra function parameter, you can store the         /// 
.................... ///     result string into a specified location.                          /// 
.................... ///   * The output string of ctime() and asctime() are not statically     /// 
.................... ///     allocated.  That means any other code that runs after ctime()     /// 
.................... ///     or asctime() can corrupt the result value.  Either perform        /// 
.................... ///     a string copy of the result into a new location, or use the       /// 
.................... ///     optional parameter of these functions to store the result         /// 
....................  
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///   * Added timeasc(), which converts a string to a time_t.  It is      /// 
.................... ///      basically the reverse of asctime().  Returns TRUE if successful  /// 
.................... ///      conversion, FALSE if not because format is wrong.                /// 
.................... ///   * Added TIME_T_USES_2010.  Normally time_t is number of seconds     /// 
.................... ///      since January 1 1970.  However, if time_t is a 32bit number this /// 
.................... ///      value will rollover sometime in 2032.  If TIME_T_USES_2010 is    /// 
.................... ///      defined then time_t is number of seconds since January 1 2010,   /// 
.................... ///      and a 32bit time_t won't rollover until 2072.   Most modern      /// 
.................... ///      operating systems (like Windows and Linux) uses a 64bit time_t   /// 
.................... ///      so they aren't effected.  If you are interfacing with another    /// 
.................... ///      system that uses a normal time_t, then that system will need to  /// 
.................... ///      add 1262304000 to the value coming from this library.            /// 
.................... ///      To enable this feature, then #define TIME_T_USES_2010            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... /// VERSION HISTORY                                                     /// 
.................... ///                                                                     /// 
.................... /// June 9 2015:                                                        /// 
.................... ///   Fixed the struct_tm typedef so 'struct tm' would be legal         /// 
.................... ///      syntax.                                                        /// 
.................... ///   The parameters that CCS added to asctime() and ctime() are now    /// 
.................... ///      optional.                                                      /// 
.................... ///   Fixed a bug where tm_mday was sometimes off by 1 day.             /// 
.................... ///                                                                     /// 
.................... /// September 25 2014:                                                  /// 
.................... ///   Cleaned up documentation.                                         /// 
.................... ///   Added timeasc().                                                  /// 
.................... ///   Added TIME_T_USES_2010 compile time option.                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct tm 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (1-31) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* returns number of ticks incremented at CLOCKS_PER_SECOND rate.  This 
....................    function must be provided by the library of your timebase */ 
.................... clock_t clock(void); 
....................  
.................... /* returns time in seconds since January 1 1970 (or January 1 2010 if  
....................    TIME_T_USES_2010 is being used).  This function must be provided by the 
....................    library of your timebase.  For example, see CCS's ds1305.c driver. */ 
.................... time_t time(time_t * timer); 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier); 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime(struct_tm * timeptr, char *szTime = 0); 
....................  
.................... /* the inverse of asctime().  you can skip the wday portion of the string, and 
....................    then this function will not populate the tm_wday in pTm.  If you do skip 
....................    the wday portion of the string, then you can use localtime(mktime()) to 
....................    populate tm_wday with the correct value based on the date.  if pTm is 
....................    NULL it won't save result, but function will still return TRUE or FALSE. 
....................    Function returns TRUE if the format of the input string is valid. */ 
.................... int1 timeasc(struct_tm *pTm, char *szTime); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime(time_t * timer, char *szTime = 0); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime ( time_t * timer ); 
.................... #define gmtime(t) localtime(t) 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTime(struct_tm * nTime); 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTimeSec(time_t sTime); 
....................  
.................... /* Get the time of your system.  This is similar to the standard time() 
....................    function, but this returns directly to a struct_tm.  Since most RTC's work 
....................    with a structure similar to struct_tm, this may be more effecient to use 
....................    than time().   This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void GetTime(struct_tm *pRetTm); 
....................  
.................... /* Initialize your timebase. This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
044E:  CLRF   22
044F:  CLRF   23
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
02ED:  MOVF   27,W
02EE:  MOVWF  60
02EF:  MOVF   26,W
02F0:  MOVWF  5F
02F1:  MOVF   25,W
02F2:  MOVWF  5E
02F3:  MOVF   24,W
02F4:  MOVWF  5D
02F5:  MOVLW  41
02F6:  MOVWF  64
02F7:  MOVLW  C6
02F8:  MOVWF  63
02F9:  MOVLW  4E
02FA:  MOVWF  62
02FB:  MOVLW  6D
02FC:  MOVWF  61
*
0326:  MOVLW  39
0327:  ADDWF  77,W
0328:  MOVWF  24
0329:  MOVF   78,W
032A:  MOVWF  25
032B:  MOVLW  30
032C:  BTFSC  03.0
032D:  MOVLW  31
032E:  ADDWF  25,F
032F:  MOVF   79,W
0330:  MOVWF  26
0331:  MOVLW  00
0332:  BTFSC  03.0
0333:  MOVLW  01
0334:  ADDWF  26,F
0335:  MOVF   7A,W
0336:  MOVWF  27
0337:  MOVLW  00
0338:  BTFSC  03.0
0339:  MOVLW  01
033A:  ADDWF  27,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
033B:  MOVF   26,W
033C:  MOVWF  77
033D:  MOVF   27,W
033E:  MOVWF  78
033F:  CLRF   79
0340:  CLRF   7A
0341:  MOVF   27,W
0342:  MOVWF  5F
0343:  MOVF   26,W
0344:  MOVWF  5E
0345:  MOVF   27,W
0346:  MOVWF  61
0347:  MOVF   26,W
0348:  MOVWF  60
0349:  MOVLW  7F
034A:  MOVWF  63
034B:  MOVLW  FF
034C:  MOVWF  62
034D:  CALL   2C8
034E:  MOVF   77,W
034F:  MOVWF  78
0350:  MOVF   7A,W
0351:  MOVWF  79
0352:  BCF    0A.3
0353:  BCF    0A.4
0354:  GOTO   589 (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
01DA:  MOVF   61,W
01DB:  MOVWF  27
01DC:  MOVF   60,W
01DD:  MOVWF  26
01DE:  MOVF   5F,W
01DF:  MOVWF  25
01E0:  MOVF   5E,W
01E1:  MOVWF  24
01E2:  BCF    0A.3
01E3:  BCF    0A.4
01E4:  GOTO   48B (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "lcd.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................   
.................... #define LCD_ENABLE_PIN  PIN_B2                                    //// 
.................... #define LCD_RS_PIN      PIN_B3                                    //// 
.................... #define LCD_RW_PIN      PIN_B0                                    //// 
.................... #define LCD_DATA4       PIN_B4                                    //// 
.................... #define LCD_DATA5       PIN_B5                                    //// 
.................... #define LCD_DATA6       PIN_B6                                    //// 
.................... #define LCD_DATA7       PIN_B7   
....................   
....................   
....................   
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00E8:  BSF    06.4
....................    output_float(LCD_DATA5); 
00E9:  BSF    06.5
....................    output_float(LCD_DATA6); 
00EA:  BSF    06.6
....................    output_float(LCD_DATA7); 
00EB:  BSF    06.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00EC:  BCF    03.5
00ED:  BSF    06.0
00EE:  BSF    03.5
00EF:  BCF    06.0
....................    delay_cycles(1); 
00F0:  NOP
....................    lcd_output_enable(1); 
00F1:  BCF    03.5
00F2:  BSF    06.2
00F3:  BSF    03.5
00F4:  BCF    06.2
....................    delay_cycles(1); 
00F5:  NOP
....................    high = lcd_read_nibble(); 
00F6:  BCF    03.5
00F7:  CALL   0AF
00F8:  MOVF   78,W
00F9:  MOVWF  69
....................        
....................    lcd_output_enable(0); 
00FA:  BCF    06.2
00FB:  BSF    03.5
00FC:  BCF    06.2
....................    delay_cycles(1); 
00FD:  NOP
....................    lcd_output_enable(1); 
00FE:  BCF    03.5
00FF:  BSF    06.2
0100:  BSF    03.5
0101:  BCF    06.2
....................    delay_us(1); 
0102:  GOTO   103
....................    low = lcd_read_nibble(); 
0103:  BCF    03.5
0104:  CALL   0AF
0105:  MOVF   78,W
0106:  MOVWF  68
....................        
....................    lcd_output_enable(0); 
0107:  BCF    06.2
0108:  BSF    03.5
0109:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
010A:  BCF    06.4
....................    output_drive(LCD_DATA5); 
010B:  BCF    06.5
....................    output_drive(LCD_DATA6); 
010C:  BCF    06.6
....................    output_drive(LCD_DATA7); 
010D:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
010E:  BCF    03.5
010F:  SWAPF  69,W
0110:  MOVWF  77
0111:  MOVLW  F0
0112:  ANDWF  77,F
0113:  MOVF   77,W
0114:  IORWF  68,W
0115:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00AF:  CLRF   6A
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00B0:  BSF    03.5
00B1:  BSF    06.4
00B2:  MOVLW  00
00B3:  BCF    03.5
00B4:  BTFSC  06.4
00B5:  MOVLW  01
00B6:  IORWF  6A,F
....................    n |= input(LCD_DATA5) << 1; 
00B7:  BSF    03.5
00B8:  BSF    06.5
00B9:  MOVLW  00
00BA:  BCF    03.5
00BB:  BTFSC  06.5
00BC:  MOVLW  01
00BD:  MOVWF  77
00BE:  BCF    03.0
00BF:  RLF    77,F
00C0:  MOVF   77,W
00C1:  IORWF  6A,F
....................    n |= input(LCD_DATA6) << 2; 
00C2:  BSF    03.5
00C3:  BSF    06.6
00C4:  MOVLW  00
00C5:  BCF    03.5
00C6:  BTFSC  06.6
00C7:  MOVLW  01
00C8:  MOVWF  77
00C9:  RLF    77,F
00CA:  RLF    77,F
00CB:  MOVLW  FC
00CC:  ANDWF  77,F
00CD:  MOVF   77,W
00CE:  IORWF  6A,F
....................    n |= input(LCD_DATA7) << 3; 
00CF:  BSF    03.5
00D0:  BSF    06.7
00D1:  MOVLW  00
00D2:  BCF    03.5
00D3:  BTFSC  06.7
00D4:  MOVLW  01
00D5:  MOVWF  77
00D6:  RLF    77,F
00D7:  RLF    77,F
00D8:  RLF    77,F
00D9:  MOVLW  F8
00DA:  ANDWF  77,F
00DB:  MOVF   77,W
00DC:  IORWF  6A,F
....................     
....................    return(n); 
00DD:  MOVF   6A,W
00DE:  MOVWF  78
....................   #else 
00DF:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0083:  BTFSC  69.0
0084:  GOTO   087
0085:  BCF    06.4
0086:  GOTO   088
0087:  BSF    06.4
0088:  BSF    03.5
0089:  BCF    06.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
008A:  BCF    03.5
008B:  BTFSC  69.1
008C:  GOTO   08F
008D:  BCF    06.5
008E:  GOTO   090
008F:  BSF    06.5
0090:  BSF    03.5
0091:  BCF    06.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0092:  BCF    03.5
0093:  BTFSC  69.2
0094:  GOTO   097
0095:  BCF    06.6
0096:  GOTO   098
0097:  BSF    06.6
0098:  BSF    03.5
0099:  BCF    06.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
009A:  BCF    03.5
009B:  BTFSC  69.3
009C:  GOTO   09F
009D:  BCF    06.7
009E:  GOTO   0A0
009F:  BSF    06.7
00A0:  BSF    03.5
00A1:  BCF    06.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00A2:  NOP
....................    lcd_output_enable(1); 
00A3:  BCF    03.5
00A4:  BSF    06.2
00A5:  BSF    03.5
00A6:  BCF    06.2
....................    delay_us(2); 
00A7:  GOTO   0A8
00A8:  GOTO   0A9
....................    lcd_output_enable(0); 
00A9:  BCF    03.5
00AA:  BCF    06.2
00AB:  BSF    03.5
00AC:  BCF    06.2
00AD:  BCF    03.5
00AE:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00E0:  BSF    03.5
00E1:  BCF    06.2
....................    lcd_rs_tris(); 
00E2:  BCF    06.3
....................    lcd_rw_tris(); 
00E3:  BCF    06.0
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00E4:  BCF    03.5
00E5:  BCF    06.3
00E6:  BSF    03.5
00E7:  BCF    06.3
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0116:  MOVF   78,W
0117:  MOVWF  68
0118:  BTFSS  68.7
0119:  GOTO   11C
011A:  BSF    03.5
011B:  GOTO   0E8
....................    lcd_output_rs(address); 
011C:  MOVF   66,F
011D:  BTFSS  03.2
011E:  GOTO   121
011F:  BCF    06.3
0120:  GOTO   122
0121:  BSF    06.3
0122:  BSF    03.5
0123:  BCF    06.3
....................    delay_cycles(1); 
0124:  NOP
....................    lcd_output_rw(0); 
0125:  BCF    03.5
0126:  BCF    06.0
0127:  BSF    03.5
0128:  BCF    06.0
....................    delay_cycles(1); 
0129:  NOP
....................    lcd_output_enable(0); 
012A:  BCF    03.5
012B:  BCF    06.2
012C:  BSF    03.5
012D:  BCF    06.2
....................    lcd_send_nibble(n >> 4); 
012E:  BCF    03.5
012F:  SWAPF  67,W
0130:  MOVWF  68
0131:  MOVLW  0F
0132:  ANDWF  68,F
0133:  MOVF   68,W
0134:  MOVWF  69
0135:  CALL   083
....................    lcd_send_nibble(n & 0xf); 
0136:  MOVF   67,W
0137:  ANDLW  0F
0138:  MOVWF  68
0139:  MOVWF  69
013A:  CALL   083
013B:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
013C:  MOVLW  28
013D:  MOVWF  5E
013E:  MOVLW  0C
013F:  MOVWF  5F
0140:  MOVLW  01
0141:  MOVWF  60
0142:  MOVLW  06
0143:  MOVWF  61
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0144:  BCF    06.2
0145:  BSF    03.5
0146:  BCF    06.2
....................    lcd_output_rs(0); 
0147:  BCF    03.5
0148:  BCF    06.3
0149:  BSF    03.5
014A:  BCF    06.3
....................    lcd_output_rw(0); 
014B:  BCF    03.5
014C:  BCF    06.0
014D:  BSF    03.5
014E:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
014F:  BCF    06.4
....................    output_drive(LCD_DATA5); 
0150:  BCF    06.5
....................    output_drive(LCD_DATA6); 
0151:  BCF    06.6
....................    output_drive(LCD_DATA7); 
0152:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0153:  BCF    06.2
....................    lcd_rs_tris(); 
0154:  BCF    06.3
....................    lcd_rw_tris(); 
0155:  BCF    06.0
....................  #endif 
....................      
....................    delay_ms(15); 
0156:  MOVLW  0F
0157:  BCF    03.5
0158:  MOVWF  62
0159:  CALL   06F
....................    for(i=1;i<=3;++i) 
015A:  MOVLW  01
015B:  MOVWF  5D
015C:  MOVF   5D,W
015D:  SUBLW  03
015E:  BTFSS  03.0
015F:  GOTO   168
....................    { 
....................        lcd_send_nibble(3); 
0160:  MOVLW  03
0161:  MOVWF  69
0162:  CALL   083
....................        delay_ms(5); 
0163:  MOVLW  05
0164:  MOVWF  62
0165:  CALL   06F
0166:  INCF   5D,F
0167:  GOTO   15C
....................    } 
....................     
....................    lcd_send_nibble(2); 
0168:  MOVLW  02
0169:  MOVWF  69
016A:  CALL   083
....................    delay_ms(5); 
016B:  MOVLW  05
016C:  MOVWF  62
016D:  CALL   06F
....................    for(i=0;i<=3;++i) 
016E:  CLRF   5D
016F:  MOVF   5D,W
0170:  SUBLW  03
0171:  BTFSS  03.0
0172:  GOTO   17F
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0173:  MOVLW  5E
0174:  ADDWF  5D,W
0175:  MOVWF  04
0176:  BCF    03.7
0177:  MOVF   00,W
0178:  MOVWF  62
0179:  CLRF   66
017A:  MOVF   62,W
017B:  MOVWF  67
017C:  CALL   0E0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
017D:  INCF   5D,F
017E:  GOTO   16F
017F:  BCF    0A.3
0180:  BCF    0A.4
0181:  GOTO   472 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01E5:  DECFSZ 63,W
01E6:  GOTO   1E8
01E7:  GOTO   1EB
....................       address=LCD_LINE_TWO; 
01E8:  MOVLW  40
01E9:  MOVWF  64
01EA:  GOTO   1EC
....................    else 
....................       address=0; 
01EB:  CLRF   64
....................       
....................    address+=x-1; 
01EC:  MOVLW  01
01ED:  SUBWF  62,W
01EE:  ADDWF  64,F
....................    lcd_send_byte(0,0x80|address); 
01EF:  MOVF   64,W
01F0:  IORLW  80
01F1:  MOVWF  65
01F2:  CLRF   66
01F3:  MOVF   65,W
01F4:  MOVWF  67
01F5:  CALL   0E0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01F6:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01F7:  MOVF   61,W
01F8:  XORLW  07
01F9:  BTFSC  03.2
01FA:  GOTO   205
01FB:  XORLW  0B
01FC:  BTFSC  03.2
01FD:  GOTO   20A
01FE:  XORLW  06
01FF:  BTFSC  03.2
0200:  GOTO   212
0201:  XORLW  02
0202:  BTFSC  03.2
0203:  GOTO   218
0204:  GOTO   21D
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0205:  MOVLW  01
0206:  MOVWF  62
0207:  MOVWF  63
0208:  CALL   1E5
0209:  GOTO   222
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
020A:  CLRF   66
020B:  MOVLW  01
020C:  MOVWF  67
020D:  CALL   0E0
....................                      delay_ms(2); 
020E:  MOVLW  02
020F:  MOVWF  62
0210:  CALL   06F
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0211:  GOTO   222
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0212:  MOVLW  01
0213:  MOVWF  62
0214:  MOVLW  02
0215:  MOVWF  63
0216:  CALL   1E5
0217:  GOTO   222
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0218:  CLRF   66
0219:  MOVLW  10
021A:  MOVWF  67
021B:  CALL   0E0
021C:  GOTO   222
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
021D:  MOVLW  01
021E:  MOVWF  66
021F:  MOVF   61,W
0220:  MOVWF  67
0221:  CALL   0E0
....................      #endif 
....................    } 
0222:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #define RESET_BUTTON    PIN_d0 
.................... #DEFINE n 4 
....................  
....................  
.................... void main() 
*
040B:  MOVF   03,W
040C:  ANDLW  1F
040D:  MOVWF  03
040E:  MOVLW  71
040F:  BSF    03.5
0410:  MOVWF  0F
0411:  CLRF   10
0412:  MOVF   0F,W
0413:  BSF    03.6
0414:  BCF    07.3
0415:  MOVLW  0C
0416:  BCF    03.6
0417:  MOVWF  19
0418:  MOVLW  A2
0419:  MOVWF  18
041A:  MOVLW  90
041B:  BCF    03.5
041C:  MOVWF  18
041D:  CLRF   29
041E:  CLRF   28
041F:  BSF    03.5
0420:  BSF    03.6
0421:  MOVF   09,W
0422:  ANDLW  C0
0423:  MOVWF  09
0424:  BCF    03.6
0425:  BCF    1F.4
0426:  BCF    1F.5
0427:  MOVLW  00
0428:  BSF    03.6
0429:  MOVWF  08
042A:  BCF    03.5
042B:  CLRF   07
042C:  CLRF   08
042D:  CLRF   09
042E:  BCF    03.6
042F:  CLRF   21
0430:  MOVLW  6C
0431:  MOVWF  20
0432:  MOVLW  08
0433:  MOVWF  6C
0434:  CLRF   6E
0435:  MOVLW  A0
0436:  MOVWF  6D
0437:  MOVLW  4D
0438:  BSF    03.5
0439:  MOVWF  20
043A:  MOVLW  01
043B:  MOVWF  22
043C:  MOVLW  10
043D:  MOVWF  21
043E:  MOVLW  5D
043F:  BCF    03.5
0440:  BSF    03.6
0441:  MOVWF  10
0442:  MOVLW  01
0443:  MOVWF  12
0444:  MOVLW  90
0445:  MOVWF  11
0446:  MOVLW  5D
0447:  BSF    03.5
0448:  MOVWF  10
0449:  CLRF   12
044A:  CLRF   11
044B:  BCF    03.5
044C:  BCF    03.6
044D:  BCF    03.7
*
0470:  CLRF   4A
.................... {   
.................... //!   int primeNum[10] = {1091,1427,1753,1571,1291,2671,701,373,661,281}; 
....................    int board[n][n] = {0}; 
*
0450:  CLRF   2A
0451:  CLRF   2B
0452:  CLRF   2C
0453:  CLRF   2D
0454:  CLRF   2E
0455:  CLRF   2F
0456:  CLRF   30
0457:  CLRF   31
0458:  CLRF   32
0459:  CLRF   33
045A:  CLRF   34
045B:  CLRF   35
045C:  CLRF   36
045D:  CLRF   37
045E:  CLRF   38
045F:  CLRF   39
....................    int freePos[n*n]={0}; 
0460:  CLRF   3A
0461:  CLRF   3B
0462:  CLRF   3C
0463:  CLRF   3D
0464:  CLRF   3E
0465:  CLRF   3F
0466:  CLRF   40
0467:  CLRF   41
0468:  CLRF   42
0469:  CLRF   43
046A:  CLRF   44
046B:  CLRF   45
046C:  CLRF   46
046D:  CLRF   47
046E:  CLRF   48
046F:  CLRF   49
.................... //!   int gen1 = 211, gen2 = 257; 
....................    int score = 0; 
....................    char keyInput;//get input. 
....................    int randPos;//random number position to fill a new item(number 2) in board. 
....................    int newPos; 
....................    int value; 
....................    boolean canMove; 
....................     
....................    lcd_init(); 
0471:  GOTO   13C
....................    delay_ms(6); 
0472:  MOVLW  06
0473:  MOVWF  62
0474:  CALL   06F
....................     
....................    printf ("\t\t< Welcome to 2048 game >\r\n"); 
0475:  MOVLW  04
0476:  BSF    03.6
0477:  MOVWF  0D
0478:  MOVLW  00
0479:  MOVWF  0F
047A:  BCF    03.6
047B:  CALL   182
....................    printf ("'a' = Left  'd' = Right  'w' = Up  's' = Down\r\n\n"); 
047C:  MOVLW  13
047D:  BSF    03.6
047E:  MOVWF  0D
047F:  MOVLW  00
0480:  MOVWF  0F
0481:  BCF    03.6
0482:  CALL   182
....................    srand(get_timer0()); 
0483:  MOVF   01,W
0484:  MOVWF  5D
0485:  CLRF   61
0486:  CLRF   60
0487:  CLRF   5F
0488:  MOVF   5D,W
0489:  MOVWF  5E
048A:  GOTO   1DA
....................    while(TRUE) { 
....................       printf(lcd_putc,"\fYour score\n%u", score); 
048B:  MOVLW  2C
048C:  BSF    03.6
048D:  MOVWF  0D
048E:  MOVLW  00
048F:  MOVWF  0F
0490:  BCF    03.0
0491:  MOVLW  0C
0492:  BCF    03.6
0493:  MOVWF  5D
0494:  GOTO   223
0495:  MOVF   4A,W
0496:  MOVWF  5D
0497:  MOVLW  1B
0498:  MOVWF  5E
0499:  GOTO   291
....................       delay_ms(1); 
049A:  MOVLW  01
049B:  MOVWF  62
049C:  CALL   06F
....................        
....................       //---------------------------game over check-----------------------------------------// 
....................       boolean canMove = false; 
....................       int count = 0; 
049D:  BCF    4F.1
049E:  CLRF   50
....................       for(int i=0;i<n;i++){ 
049F:  CLRF   51
04A0:  MOVF   51,W
04A1:  SUBLW  03
04A2:  BTFSS  03.0
04A3:  GOTO   57E
....................          for(int j=0;j<n;j++){ 
04A4:  CLRF   52
04A5:  MOVF   52,W
04A6:  SUBLW  03
04A7:  BTFSS  03.0
04A8:  GOTO   57C
....................             if(board[i][j] == 0){ 
04A9:  RLF    51,W
04AA:  MOVWF  77
04AB:  RLF    77,F
04AC:  MOVLW  FC
04AD:  ANDWF  77,F
04AE:  MOVF   77,W
04AF:  ADDWF  52,W
04B0:  ADDLW  2A
04B1:  MOVWF  04
04B2:  BCF    03.7
04B3:  MOVF   00,F
04B4:  BTFSS  03.2
04B5:  GOTO   4C4
....................                freePos[count++] = (i * n) + j; 
04B6:  MOVF   50,W
04B7:  INCF   50,F
04B8:  ADDLW  3A
04B9:  MOVWF  04
04BA:  BCF    03.7
04BB:  RLF    51,W
04BC:  MOVWF  77
04BD:  RLF    77,F
04BE:  MOVLW  FC
04BF:  ANDWF  77,F
04C0:  MOVF   77,W
04C1:  ADDWF  52,W
04C2:  MOVWF  00
....................                canMove = true; 
04C3:  BSF    4F.1
....................             } 
....................             if((i != 0 && (board[i-1][j] == 0 || board[i-1][j] == board[i][j])) || 
....................                (i != n-1 && (board[i+1][j] == 0 || board[i+1][j] == board[i][j])) || 
....................                (j != 0 && (board[i][j-1] == 0 || board[i][j-1] == board[i][j])) || 
....................                (j != n-1 && (board[i][j+1] == 0 || board[i][j+1] == board[i][j]))) canMove = true; 
04C4:  MOVF   51,F
04C5:  BTFSC  03.2
04C6:  GOTO   4F2
04C7:  MOVLW  01
04C8:  SUBWF  51,W
04C9:  MOVWF  77
04CA:  RLF    77,F
04CB:  RLF    77,F
04CC:  MOVLW  FC
04CD:  ANDWF  77,F
04CE:  MOVF   77,W
04CF:  ADDWF  52,W
04D0:  ADDLW  2A
04D1:  MOVWF  04
04D2:  BCF    03.7
04D3:  MOVF   00,F
04D4:  BTFSC  03.2
04D5:  GOTO   579
04D6:  MOVLW  01
04D7:  SUBWF  51,W
04D8:  MOVWF  77
04D9:  RLF    77,F
04DA:  RLF    77,F
04DB:  MOVLW  FC
04DC:  ANDWF  77,F
04DD:  MOVF   77,W
04DE:  ADDWF  52,W
04DF:  ADDLW  2A
04E0:  MOVWF  04
04E1:  BCF    03.7
04E2:  MOVF   00,W
04E3:  MOVWF  5D
04E4:  RLF    51,W
04E5:  MOVWF  77
04E6:  RLF    77,F
04E7:  MOVLW  FC
04E8:  ANDWF  77,F
04E9:  MOVF   77,W
04EA:  ADDWF  52,W
04EB:  ADDLW  2A
04EC:  MOVWF  04
04ED:  BCF    03.7
04EE:  MOVF   00,W
04EF:  SUBWF  5D,W
04F0:  BTFSC  03.2
04F1:  GOTO   579
04F2:  MOVF   51,W
04F3:  SUBLW  03
04F4:  BTFSC  03.2
04F5:  GOTO   521
04F6:  MOVLW  01
04F7:  ADDWF  51,W
04F8:  MOVWF  77
04F9:  RLF    77,F
04FA:  RLF    77,F
04FB:  MOVLW  FC
04FC:  ANDWF  77,F
04FD:  MOVF   77,W
04FE:  ADDWF  52,W
04FF:  ADDLW  2A
0500:  MOVWF  04
0501:  BCF    03.7
0502:  MOVF   00,F
0503:  BTFSC  03.2
0504:  GOTO   579
0505:  MOVLW  01
0506:  ADDWF  51,W
0507:  MOVWF  77
0508:  RLF    77,F
0509:  RLF    77,F
050A:  MOVLW  FC
050B:  ANDWF  77,F
050C:  MOVF   77,W
050D:  ADDWF  52,W
050E:  ADDLW  2A
050F:  MOVWF  04
0510:  BCF    03.7
0511:  MOVF   00,W
0512:  MOVWF  5D
0513:  RLF    51,W
0514:  MOVWF  77
0515:  RLF    77,F
0516:  MOVLW  FC
0517:  ANDWF  77,F
0518:  MOVF   77,W
0519:  ADDWF  52,W
051A:  ADDLW  2A
051B:  MOVWF  04
051C:  BCF    03.7
051D:  MOVF   00,W
051E:  SUBWF  5D,W
051F:  BTFSC  03.2
0520:  GOTO   579
0521:  MOVF   52,F
0522:  BTFSC  03.2
0523:  GOTO   54D
0524:  RLF    51,W
0525:  MOVWF  5D
0526:  RLF    5D,F
0527:  MOVLW  FC
0528:  ANDWF  5D,F
0529:  MOVLW  01
052A:  SUBWF  52,W
052B:  ADDWF  5D,W
052C:  ADDLW  2A
052D:  MOVWF  04
052E:  BCF    03.7
052F:  MOVF   00,F
0530:  BTFSC  03.2
0531:  GOTO   579
0532:  RLF    51,W
0533:  MOVWF  5D
0534:  RLF    5D,F
0535:  MOVLW  FC
0536:  ANDWF  5D,F
0537:  MOVLW  01
0538:  SUBWF  52,W
0539:  ADDWF  5D,W
053A:  ADDLW  2A
053B:  MOVWF  04
053C:  BCF    03.7
053D:  MOVF   00,W
053E:  MOVWF  5D
053F:  RLF    51,W
0540:  MOVWF  77
0541:  RLF    77,F
0542:  MOVLW  FC
0543:  ANDWF  77,F
0544:  MOVF   77,W
0545:  ADDWF  52,W
0546:  ADDLW  2A
0547:  MOVWF  04
0548:  BCF    03.7
0549:  MOVF   00,W
054A:  SUBWF  5D,W
054B:  BTFSC  03.2
054C:  GOTO   579
054D:  MOVF   52,W
054E:  SUBLW  03
054F:  BTFSC  03.2
0550:  GOTO   57A
0551:  RLF    51,W
0552:  MOVWF  5D
0553:  RLF    5D,F
0554:  MOVLW  FC
0555:  ANDWF  5D,F
0556:  MOVLW  01
0557:  ADDWF  52,W
0558:  ADDWF  5D,W
0559:  ADDLW  2A
055A:  MOVWF  04
055B:  BCF    03.7
055C:  MOVF   00,F
055D:  BTFSC  03.2
055E:  GOTO   579
055F:  RLF    51,W
0560:  MOVWF  5D
0561:  RLF    5D,F
0562:  MOVLW  FC
0563:  ANDWF  5D,F
0564:  MOVLW  01
0565:  ADDWF  52,W
0566:  ADDWF  5D,W
0567:  ADDLW  2A
0568:  MOVWF  04
0569:  BCF    03.7
056A:  MOVF   00,W
056B:  MOVWF  5D
056C:  RLF    51,W
056D:  MOVWF  77
056E:  RLF    77,F
056F:  MOVLW  FC
0570:  ANDWF  77,F
0571:  MOVF   77,W
0572:  ADDWF  52,W
0573:  ADDLW  2A
0574:  MOVWF  04
0575:  BCF    03.7
0576:  MOVF   00,W
0577:  SUBWF  5D,W
0578:  BTFSC  03.2
0579:  BSF    4F.1
057A:  INCF   52,F
057B:  GOTO   4A5
....................          } 
057C:  INCF   51,F
057D:  GOTO   4A0
....................       } 
....................       if(!canMove) { 
057E:  BTFSC  4F.1
057F:  GOTO   588
....................          printf("\t\t\t!Game Over!\r\n"); 
0580:  MOVLW  34
0581:  BSF    03.6
0582:  MOVWF  0D
0583:  MOVLW  00
0584:  MOVWF  0F
0585:  BCF    03.6
0586:  CALL   182
....................          break; 
0587:  GOTO   7FB
....................       } 
....................        //---------------------------game over check-----------------------------------------// 
....................        
....................       //---------------------------random Generator-----------------------------------------// 
.................... //!      randPos = 0; 
.................... //!      if(gen2 == 0) gen2 = primeNum[count%10]; 
.................... //!      for(int i=0;i<count;i++){ 
.................... //!         randPos += (freePos[i]*freePos[i])%43; 
.................... //!      } 
.................... //!      randPos = abs((int)((gen1%41) * randPos))%count; 
.................... //!      int gen1Tmp = gen1; 
.................... //!      gen1 = gen2; 
.................... //!      gen2 = (int)(gen2 * gen1Tmp * randPos + 1427); 
....................        
....................       randPos = rand() %count; 
0588:  GOTO   2ED
0589:  MOVF   79,W
058A:  MOVWF  5E
058B:  MOVF   78,W
058C:  MOVWF  5D
058D:  MOVF   79,W
058E:  MOVWF  61
058F:  MOVF   78,W
0590:  MOVWF  60
0591:  CLRF   63
0592:  MOVF   50,W
0593:  MOVWF  62
0594:  CALL   2C8
0595:  MOVF   77,W
0596:  MOVWF  4C
....................       board[freePos[randPos]/n][freePos[randPos]%n] = 2; //fill a new item(number 2) in board. 
0597:  MOVLW  3A
0598:  ADDWF  4C,W
0599:  MOVWF  04
059A:  BCF    03.7
059B:  RRF    00,W
059C:  MOVWF  77
059D:  RRF    77,F
059E:  MOVLW  3F
059F:  ANDWF  77,F
05A0:  MOVF   77,W
05A1:  RLF    77,W
05A2:  MOVWF  5D
05A3:  RLF    5D,F
05A4:  MOVLW  FC
05A5:  ANDWF  5D,F
05A6:  MOVLW  3A
05A7:  ADDWF  4C,W
05A8:  MOVWF  04
05A9:  BCF    03.7
05AA:  MOVF   00,W
05AB:  ANDLW  03
05AC:  ADDWF  5D,W
05AD:  ADDLW  2A
05AE:  MOVWF  04
05AF:  BCF    03.7
05B0:  MOVLW  02
05B1:  MOVWF  00
....................       //---------------------------random Generator-----------------------------------------// 
....................        
....................       //---------------------------show Board-----------------------------------------// 
....................       for(int i=0;i<n;i++){ 
05B2:  CLRF   53
05B3:  MOVF   53,W
05B4:  SUBLW  03
05B5:  BTFSS  03.0
05B6:  GOTO   5E1
....................          printf("\t"); 
05B7:  MOVLW  09
05B8:  BTFSS  0C.4
05B9:  GOTO   5B8
05BA:  MOVWF  19
....................          for(int j=0;j<n;j++){ 
05BB:  CLRF   54
05BC:  MOVF   54,W
05BD:  SUBLW  03
05BE:  BTFSS  03.0
05BF:  GOTO   5D7
....................             printf("\t%d", board[i][j]); 
05C0:  RLF    53,W
05C1:  MOVWF  77
05C2:  RLF    77,F
05C3:  MOVLW  FC
05C4:  ANDWF  77,F
05C5:  MOVF   77,W
05C6:  ADDWF  54,W
05C7:  ADDLW  2A
05C8:  MOVWF  04
05C9:  BCF    03.7
05CA:  MOVF   00,W
05CB:  MOVWF  5D
05CC:  MOVLW  09
05CD:  BTFSS  0C.4
05CE:  GOTO   5CD
05CF:  MOVWF  19
05D0:  MOVF   5D,W
05D1:  MOVWF  5F
05D2:  MOVLW  18
05D3:  MOVWF  60
05D4:  CALL   355
05D5:  INCF   54,F
05D6:  GOTO   5BC
....................          } 
....................          printf("\r\n"); 
05D7:  MOVLW  0D
05D8:  BTFSS  0C.4
05D9:  GOTO   5D8
05DA:  MOVWF  19
05DB:  MOVLW  0A
05DC:  BTFSS  0C.4
05DD:  GOTO   5DC
05DE:  MOVWF  19
05DF:  INCF   53,F
05E0:  GOTO   5B3
....................       } 
....................       printf("\t\tadd new [2] in (%d,%d)\r\n",freePos[randPos]/n,freePos[randPos]%n); 
05E1:  MOVLW  3A
05E2:  ADDWF  4C,W
05E3:  MOVWF  04
05E4:  BCF    03.7
05E5:  RRF    00,W
05E6:  MOVWF  5D
05E7:  RRF    5D,F
05E8:  MOVLW  3F
05E9:  ANDWF  5D,F
05EA:  MOVLW  3A
05EB:  ADDWF  4C,W
05EC:  MOVWF  04
05ED:  BCF    03.7
05EE:  MOVF   00,W
05EF:  ANDLW  03
05F0:  MOVWF  5E
05F1:  MOVLW  3D
05F2:  BSF    03.6
05F3:  MOVWF  0D
05F4:  MOVLW  00
05F5:  MOVWF  0F
05F6:  BCF    03.0
05F7:  MOVLW  12
05F8:  BCF    03.6
05F9:  MOVWF  5F
05FA:  GOTO   3B0
05FB:  MOVF   5D,W
05FC:  MOVWF  5F
05FD:  MOVLW  18
05FE:  MOVWF  60
05FF:  CALL   355
0600:  MOVLW  2C
0601:  BTFSS  0C.4
0602:  GOTO   601
0603:  MOVWF  19
0604:  MOVF   5E,W
0605:  MOVWF  5F
0606:  MOVLW  18
0607:  MOVWF  60
0608:  CALL   355
0609:  MOVLW  29
060A:  BTFSS  0C.4
060B:  GOTO   60A
060C:  MOVWF  19
060D:  MOVLW  0D
060E:  BTFSS  0C.4
060F:  GOTO   60E
0610:  MOVWF  19
0611:  MOVLW  0A
0612:  BTFSS  0C.4
0613:  GOTO   612
0614:  MOVWF  19
....................       printf("\r\n"); 
0615:  MOVLW  0D
0616:  BTFSS  0C.4
0617:  GOTO   616
0618:  MOVWF  19
0619:  MOVLW  0A
061A:  BTFSS  0C.4
061B:  GOTO   61A
061C:  MOVWF  19
....................       printf("\r\n"); 
061D:  MOVLW  0D
061E:  BTFSS  0C.4
061F:  GOTO   61E
0620:  MOVWF  19
0621:  MOVLW  0A
0622:  BTFSS  0C.4
0623:  GOTO   622
0624:  MOVWF  19
....................       //---------------------------show Board-----------------------------------------// 
....................        
....................       //---------------------------get input and move-----------------------------------------// 
....................       keyInput = getc(); 
0625:  BTFSS  0C.5
0626:  GOTO   625
0627:  MOVF   1A,W
0628:  MOVWF  4B
....................       switch(keyInput){ 
0629:  MOVF   4B,W
062A:  XORLW  61
062B:  BTFSC  03.2
062C:  GOTO   637
062D:  XORLW  05
062E:  BTFSC  03.2
062F:  GOTO   6A4
0630:  XORLW  13
0631:  BTFSC  03.2
0632:  GOTO   716
0633:  XORLW  04
0634:  BTFSC  03.2
0635:  GOTO   785
0636:  GOTO   7FA
....................          case 'a': //move items to the left if can. 
....................             printf("\t\t\t----Left----\r\n"); 
0637:  MOVLW  4B
0638:  BSF    03.6
0639:  MOVWF  0D
063A:  MOVLW  00
063B:  MOVWF  0F
063C:  BCF    03.6
063D:  CALL   182
....................             for(int i=0;i<n;i++){ 
063E:  CLRF   55
063F:  MOVF   55,W
0640:  SUBLW  03
0641:  BTFSS  03.0
0642:  GOTO   6A3
....................                for(int j=1;j<n;j++){ 
0643:  MOVLW  01
0644:  MOVWF  56
0645:  MOVF   56,W
0646:  SUBLW  03
0647:  BTFSS  03.0
0648:  GOTO   6A1
....................                   newPos = j; 
0649:  MOVF   56,W
064A:  MOVWF  4D
....................                   value = board[i][j]; 
064B:  RLF    55,W
064C:  MOVWF  77
064D:  RLF    77,F
064E:  MOVLW  FC
064F:  ANDWF  77,F
0650:  MOVF   77,W
0651:  ADDWF  56,W
0652:  ADDLW  2A
0653:  MOVWF  04
0654:  BCF    03.7
0655:  MOVF   00,W
0656:  MOVWF  4E
....................                   while(newPos > 0){ 
0657:  MOVF   4D,F
0658:  BTFSC  03.2
0659:  GOTO   67E
....................                      if(board[i][newPos-1] == 0) newPos--; //move when position in left hand empty. 
065A:  RLF    55,W
065B:  MOVWF  5D
065C:  RLF    5D,F
065D:  MOVLW  FC
065E:  ANDWF  5D,F
065F:  MOVLW  01
0660:  SUBWF  4D,W
0661:  ADDWF  5D,W
0662:  ADDLW  2A
0663:  MOVWF  04
0664:  BCF    03.7
0665:  MOVF   00,F
0666:  BTFSS  03.2
0667:  GOTO   66A
0668:  DECF   4D,F
0669:  GOTO   67D
....................                      else{ 
....................                         if(board[i][newPos-1] == value){ //move when value can sum with same number. 
066A:  RLF    55,W
066B:  MOVWF  5D
066C:  RLF    5D,F
066D:  MOVLW  FC
066E:  ANDWF  5D,F
066F:  MOVLW  01
0670:  SUBWF  4D,W
0671:  ADDWF  5D,W
0672:  ADDLW  2A
0673:  MOVWF  04
0674:  BCF    03.7
0675:  MOVF   4E,W
0676:  SUBWF  00,W
0677:  BTFSS  03.2
0678:  GOTO   67C
....................                            value*=2;  
0679:  BCF    03.0
067A:  RLF    4E,F
....................                            newPos--; 
067B:  DECF   4D,F
....................                         } 
....................                         break;//end while loop. 
067C:  GOTO   67E
....................                      } 
067D:  GOTO   657
....................                   } 
....................                   if(newPos!=j){ 
067E:  MOVF   56,W
067F:  SUBWF  4D,W
0680:  BTFSC  03.2
0681:  GOTO   69F
....................                      if(value > 2) score += value; 
0682:  MOVF   4E,W
0683:  SUBLW  02
0684:  BTFSC  03.0
0685:  GOTO   688
0686:  MOVF   4E,W
0687:  ADDWF  4A,F
....................                      board[i][newPos] = value; 
0688:  RLF    55,W
0689:  MOVWF  77
068A:  RLF    77,F
068B:  MOVLW  FC
068C:  ANDWF  77,F
068D:  MOVF   77,W
068E:  ADDWF  4D,W
068F:  ADDLW  2A
0690:  MOVWF  04
0691:  BCF    03.7
0692:  MOVF   4E,W
0693:  MOVWF  00
....................                      board[i][j] = 0; 
0694:  RLF    55,W
0695:  MOVWF  77
0696:  RLF    77,F
0697:  MOVLW  FC
0698:  ANDWF  77,F
0699:  MOVF   77,W
069A:  ADDWF  56,W
069B:  ADDLW  2A
069C:  MOVWF  04
069D:  BCF    03.7
069E:  CLRF   00
....................                   } 
069F:  INCF   56,F
06A0:  GOTO   645
....................                } 
06A1:  INCF   55,F
06A2:  GOTO   63F
....................             } 
....................              
....................             break; 
06A3:  GOTO   7FA
....................          case 'd': //move items to the right if can. 
....................             printf("\t\t\t---Right---\r\n"); 
06A4:  MOVLW  54
06A5:  BSF    03.6
06A6:  MOVWF  0D
06A7:  MOVLW  00
06A8:  MOVWF  0F
06A9:  BCF    03.6
06AA:  CALL   182
....................             for(int i=0;i<n;i++){ 
06AB:  CLRF   57
06AC:  MOVF   57,W
06AD:  SUBLW  03
06AE:  BTFSS  03.0
06AF:  GOTO   715
....................                for(int j=1;j<n;j++){ 
06B0:  MOVLW  01
06B1:  MOVWF  58
06B2:  MOVF   58,W
06B3:  SUBLW  03
06B4:  BTFSS  03.0
06B5:  GOTO   713
....................                   newPos = n-1-j; 
06B6:  MOVF   58,W
06B7:  SUBLW  03
06B8:  MOVWF  4D
....................                   value = board[i][n-1-j]; 
06B9:  RLF    57,W
06BA:  MOVWF  5D
06BB:  RLF    5D,F
06BC:  MOVLW  FC
06BD:  ANDWF  5D,F
06BE:  MOVF   58,W
06BF:  SUBLW  03
06C0:  ADDWF  5D,W
06C1:  ADDLW  2A
06C2:  MOVWF  04
06C3:  BCF    03.7
06C4:  MOVF   00,W
06C5:  MOVWF  4E
....................                   while(newPos < n-1){ 
06C6:  MOVF   4D,W
06C7:  SUBLW  02
06C8:  BTFSS  03.0
06C9:  GOTO   6EE
....................                      if(board[i][newPos+1] == 0) newPos++; //move when position in right hand empty. 
06CA:  RLF    57,W
06CB:  MOVWF  5D
06CC:  RLF    5D,F
06CD:  MOVLW  FC
06CE:  ANDWF  5D,F
06CF:  MOVLW  01
06D0:  ADDWF  4D,W
06D1:  ADDWF  5D,W
06D2:  ADDLW  2A
06D3:  MOVWF  04
06D4:  BCF    03.7
06D5:  MOVF   00,F
06D6:  BTFSS  03.2
06D7:  GOTO   6DA
06D8:  INCF   4D,F
06D9:  GOTO   6ED
....................                      else{ 
....................                         if(board[i][newPos+1] == value){ //move when value can sum with same number. 
06DA:  RLF    57,W
06DB:  MOVWF  5D
06DC:  RLF    5D,F
06DD:  MOVLW  FC
06DE:  ANDWF  5D,F
06DF:  MOVLW  01
06E0:  ADDWF  4D,W
06E1:  ADDWF  5D,W
06E2:  ADDLW  2A
06E3:  MOVWF  04
06E4:  BCF    03.7
06E5:  MOVF   4E,W
06E6:  SUBWF  00,W
06E7:  BTFSS  03.2
06E8:  GOTO   6EC
....................                            value*=2;  
06E9:  BCF    03.0
06EA:  RLF    4E,F
....................                            newPos++; 
06EB:  INCF   4D,F
....................                         } 
....................                         break;//end while loop. 
06EC:  GOTO   6EE
....................                      } 
06ED:  GOTO   6C6
....................                   } 
....................                   if(newPos!=n-1-j){ 
06EE:  MOVF   58,W
06EF:  SUBLW  03
06F0:  SUBWF  4D,W
06F1:  BTFSC  03.2
06F2:  GOTO   711
....................                      if(value > 2) score += value; 
06F3:  MOVF   4E,W
06F4:  SUBLW  02
06F5:  BTFSC  03.0
06F6:  GOTO   6F9
06F7:  MOVF   4E,W
06F8:  ADDWF  4A,F
....................                      board[i][newPos] = value; 
06F9:  RLF    57,W
06FA:  MOVWF  77
06FB:  RLF    77,F
06FC:  MOVLW  FC
06FD:  ANDWF  77,F
06FE:  MOVF   77,W
06FF:  ADDWF  4D,W
0700:  ADDLW  2A
0701:  MOVWF  04
0702:  BCF    03.7
0703:  MOVF   4E,W
0704:  MOVWF  00
....................                      board[i][n-1-j] = 0; 
0705:  RLF    57,W
0706:  MOVWF  5D
0707:  RLF    5D,F
0708:  MOVLW  FC
0709:  ANDWF  5D,F
070A:  MOVF   58,W
070B:  SUBLW  03
070C:  ADDWF  5D,W
070D:  ADDLW  2A
070E:  MOVWF  04
070F:  BCF    03.7
0710:  CLRF   00
....................                   } 
0711:  INCF   58,F
0712:  GOTO   6B2
....................                } 
0713:  INCF   57,F
0714:  GOTO   6AC
....................             } 
....................             break; 
0715:  GOTO   7FA
....................          case 'w': //move items to the top if can. 
....................             printf("\t\t\t----Top----\r\n"); 
0716:  MOVLW  5D
0717:  BSF    03.6
0718:  MOVWF  0D
0719:  MOVLW  00
071A:  MOVWF  0F
071B:  BCF    03.6
071C:  CALL   182
....................             for(int i=0;i<n;i++){ 
071D:  CLRF   59
071E:  MOVF   59,W
071F:  SUBLW  03
0720:  BTFSS  03.0
0721:  GOTO   784
....................                for(int j=1;j<n;j++){ 
0722:  MOVLW  01
0723:  MOVWF  5A
0724:  MOVF   5A,W
0725:  SUBLW  03
0726:  BTFSS  03.0
0727:  GOTO   782
....................                   newPos = j; 
0728:  MOVF   5A,W
0729:  MOVWF  4D
....................                   value = board[j][i]; 
072A:  RLF    5A,W
072B:  MOVWF  77
072C:  RLF    77,F
072D:  MOVLW  FC
072E:  ANDWF  77,F
072F:  MOVF   77,W
0730:  ADDWF  59,W
0731:  ADDLW  2A
0732:  MOVWF  04
0733:  BCF    03.7
0734:  MOVF   00,W
0735:  MOVWF  4E
....................                   while(newPos > 0){ 
0736:  MOVF   4D,F
0737:  BTFSC  03.2
0738:  GOTO   75F
....................                      if(board[newPos-1][i] == 0) newPos--; //move when position in top hand empty. 
0739:  MOVLW  01
073A:  SUBWF  4D,W
073B:  MOVWF  77
073C:  RLF    77,F
073D:  RLF    77,F
073E:  MOVLW  FC
073F:  ANDWF  77,F
0740:  MOVF   77,W
0741:  ADDWF  59,W
0742:  ADDLW  2A
0743:  MOVWF  04
0744:  BCF    03.7
0745:  MOVF   00,F
0746:  BTFSS  03.2
0747:  GOTO   74A
0748:  DECF   4D,F
0749:  GOTO   75E
....................                      else{ 
....................                         if(board[newPos-1][i] == value){ //move when value can sum with same number. 
074A:  MOVLW  01
074B:  SUBWF  4D,W
074C:  MOVWF  77
074D:  RLF    77,F
074E:  RLF    77,F
074F:  MOVLW  FC
0750:  ANDWF  77,F
0751:  MOVF   77,W
0752:  ADDWF  59,W
0753:  ADDLW  2A
0754:  MOVWF  04
0755:  BCF    03.7
0756:  MOVF   4E,W
0757:  SUBWF  00,W
0758:  BTFSS  03.2
0759:  GOTO   75D
....................                            value*=2;  
075A:  BCF    03.0
075B:  RLF    4E,F
....................                            newPos--; 
075C:  DECF   4D,F
....................                         } 
....................                         break;//end while loop. 
075D:  GOTO   75F
....................                      } 
075E:  GOTO   736
....................                   } 
....................                   if(newPos!=j){ 
075F:  MOVF   5A,W
0760:  SUBWF  4D,W
0761:  BTFSC  03.2
0762:  GOTO   780
....................                      if(value > 2) score += value; 
0763:  MOVF   4E,W
0764:  SUBLW  02
0765:  BTFSC  03.0
0766:  GOTO   769
0767:  MOVF   4E,W
0768:  ADDWF  4A,F
....................                      board[newPos][i] = value; 
0769:  RLF    4D,W
076A:  MOVWF  77
076B:  RLF    77,F
076C:  MOVLW  FC
076D:  ANDWF  77,F
076E:  MOVF   77,W
076F:  ADDWF  59,W
0770:  ADDLW  2A
0771:  MOVWF  04
0772:  BCF    03.7
0773:  MOVF   4E,W
0774:  MOVWF  00
....................                      board[j][i] = 0; 
0775:  RLF    5A,W
0776:  MOVWF  77
0777:  RLF    77,F
0778:  MOVLW  FC
0779:  ANDWF  77,F
077A:  MOVF   77,W
077B:  ADDWF  59,W
077C:  ADDLW  2A
077D:  MOVWF  04
077E:  BCF    03.7
077F:  CLRF   00
....................                   } 
0780:  INCF   5A,F
0781:  GOTO   724
....................                } 
0782:  INCF   59,F
0783:  GOTO   71E
....................             } 
....................             break; 
0784:  GOTO   7FA
....................          case 's': //move items to the bottom if can. 
....................             printf("\t\t\t---Bottom---\r\n"); 
0785:  MOVLW  66
0786:  BSF    03.6
0787:  MOVWF  0D
0788:  MOVLW  00
0789:  MOVWF  0F
078A:  BCF    03.6
078B:  CALL   182
....................             for(int i=0;i<n;i++){ 
078C:  CLRF   5B
078D:  MOVF   5B,W
078E:  SUBLW  03
078F:  BTFSS  03.0
0790:  GOTO   7FA
....................                for(int j=1;j<n;j++){ 
0791:  MOVLW  01
0792:  MOVWF  5C
0793:  MOVF   5C,W
0794:  SUBLW  03
0795:  BTFSS  03.0
0796:  GOTO   7F8
....................                   newPos = n-1-j; 
0797:  MOVF   5C,W
0798:  SUBLW  03
0799:  MOVWF  4D
....................                   value = board[n-1-j][i]; 
079A:  MOVF   5C,W
079B:  SUBLW  03
079C:  MOVWF  77
079D:  RLF    77,F
079E:  RLF    77,F
079F:  MOVLW  FC
07A0:  ANDWF  77,F
07A1:  MOVF   77,W
07A2:  ADDWF  5B,W
07A3:  ADDLW  2A
07A4:  MOVWF  04
07A5:  BCF    03.7
07A6:  MOVF   00,W
07A7:  MOVWF  4E
....................                   while(newPos < n-1){ 
07A8:  MOVF   4D,W
07A9:  SUBLW  02
07AA:  BTFSS  03.0
07AB:  GOTO   7D2
....................                      if(board[newPos+1][i] == 0) newPos++; //move when position in bottom hand empty. 
07AC:  MOVLW  01
07AD:  ADDWF  4D,W
07AE:  MOVWF  77
07AF:  RLF    77,F
07B0:  RLF    77,F
07B1:  MOVLW  FC
07B2:  ANDWF  77,F
07B3:  MOVF   77,W
07B4:  ADDWF  5B,W
07B5:  ADDLW  2A
07B6:  MOVWF  04
07B7:  BCF    03.7
07B8:  MOVF   00,F
07B9:  BTFSS  03.2
07BA:  GOTO   7BD
07BB:  INCF   4D,F
07BC:  GOTO   7D1
....................                      else{ 
....................                         if(board[newPos+1][i] == value){ //move when value can sum with same number. 
07BD:  MOVLW  01
07BE:  ADDWF  4D,W
07BF:  MOVWF  77
07C0:  RLF    77,F
07C1:  RLF    77,F
07C2:  MOVLW  FC
07C3:  ANDWF  77,F
07C4:  MOVF   77,W
07C5:  ADDWF  5B,W
07C6:  ADDLW  2A
07C7:  MOVWF  04
07C8:  BCF    03.7
07C9:  MOVF   4E,W
07CA:  SUBWF  00,W
07CB:  BTFSS  03.2
07CC:  GOTO   7D0
....................                            value*=2;  
07CD:  BCF    03.0
07CE:  RLF    4E,F
....................                            newPos++; 
07CF:  INCF   4D,F
....................                         } 
....................                         break;//end while loop. 
07D0:  GOTO   7D2
....................                      } 
07D1:  GOTO   7A8
....................                   } 
....................                   if(newPos!=n-1-j){ 
07D2:  MOVF   5C,W
07D3:  SUBLW  03
07D4:  SUBWF  4D,W
07D5:  BTFSC  03.2
07D6:  GOTO   7F6
....................                      if(value > 2) score += value; 
07D7:  MOVF   4E,W
07D8:  SUBLW  02
07D9:  BTFSC  03.0
07DA:  GOTO   7DD
07DB:  MOVF   4E,W
07DC:  ADDWF  4A,F
....................                      board[newPos][i] = value; 
07DD:  RLF    4D,W
07DE:  MOVWF  77
07DF:  RLF    77,F
07E0:  MOVLW  FC
07E1:  ANDWF  77,F
07E2:  MOVF   77,W
07E3:  ADDWF  5B,W
07E4:  ADDLW  2A
07E5:  MOVWF  04
07E6:  BCF    03.7
07E7:  MOVF   4E,W
07E8:  MOVWF  00
....................                      board[n-1-j][i] = 0; 
07E9:  MOVF   5C,W
07EA:  SUBLW  03
07EB:  MOVWF  77
07EC:  RLF    77,F
07ED:  RLF    77,F
07EE:  MOVLW  FC
07EF:  ANDWF  77,F
07F0:  MOVF   77,W
07F1:  ADDWF  5B,W
07F2:  ADDLW  2A
07F3:  MOVWF  04
07F4:  BCF    03.7
07F5:  CLRF   00
....................                   } 
07F6:  INCF   5C,F
07F7:  GOTO   793
....................                } 
07F8:  INCF   5B,F
07F9:  GOTO   78D
....................             } 
....................             break;  
....................          default: 
....................       } 
07FA:  GOTO   48B
....................       //---------------------------get input and move-----------------------------------------// 
....................        
....................    } 
....................     
.................... } 
07FB:  SLEEP

Configuration Fuses:
   Word  1: 2FC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
